{"message":"unused import: `ffi_type`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"testing.rs","byte_start":33,"byte_end":41,"line_start":1,"line_end":1,"column_start":34,"column_end":42,"is_primary":true,"text":[{"text":"use interoptopus::{ffi_function, ffi_type, function, Inventory, InventoryBuilder};","highlight_start":34,"highlight_end":42}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"testing.rs","byte_start":31,"byte_end":41,"line_start":1,"line_end":1,"column_start":32,"column_end":42,"is_primary":true,"text":[{"text":"use interoptopus::{ffi_function, ffi_type, function, Inventory, InventoryBuilder};","highlight_start":32,"highlight_end":42}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unused import: `ffi_type`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mtesting.rs:1:34\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse interoptopus::{ffi_function, ffi_type, function, Inventory, InventoryBuilder};\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                 \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"message":"trait objects without an explicit `dyn` are deprecated","code":{"code":"bare_trait_objects","explanation":null},"level":"warning","spans":[{"file_name":"testing.rs","byte_start":152,"byte_end":169,"line_start":5,"line_end":5,"column_start":36,"column_end":53,"is_primary":true,"text":[{"text":"pub extern \"C\" fn test_errors() -> std::error::Error{","highlight_start":36,"highlight_end":53}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(bare_trait_objects)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!","code":null,"level":"warning","spans":[],"children":[],"rendered":null},{"message":"for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"use `dyn`","code":null,"level":"help","spans":[{"file_name":"testing.rs","byte_start":152,"byte_end":152,"line_start":5,"line_end":5,"column_start":36,"column_end":36,"is_primary":true,"text":[{"text":"pub extern \"C\" fn test_errors() -> std::error::Error{","highlight_start":36,"highlight_end":36}],"label":null,"suggested_replacement":"dyn ","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"testing.rs","byte_start":169,"byte_end":169,"line_start":5,"line_end":5,"column_start":53,"column_end":53,"is_primary":true,"text":[{"text":"pub extern \"C\" fn test_errors() -> std::error::Error{","highlight_start":53,"highlight_end":53}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: trait objects without an explicit `dyn` are deprecated\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mtesting.rs:5:36\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m5\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub extern \"C\" fn test_errors() -> std::error::Error{\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: `#[warn(bare_trait_objects)]` on by default\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mwarning\u001b[0m\u001b[0m: this is accepted in the current edition (Rust 2018) but is a hard error in Rust 2021!\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: use `dyn`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m5\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;9m- \u001b[0m\u001b[0mpub extern \"C\" fn test_errors() -> std::error::Error{\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m5\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[38;5;10m+ \u001b[0m\u001b[0mpub extern \"C\" fn test_errors() -> \u001b[0m\u001b[0m\u001b[38;5;10mdyn \u001b[0m\u001b[0mstd::error::Error{\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\n"}
{"message":"unreachable expression","code":{"code":"unreachable_code","explanation":null},"level":"warning","spans":[{"file_name":"testing.rs","byte_start":176,"byte_end":215,"line_start":6,"line_end":6,"column_start":5,"column_end":44,"is_primary":true,"text":[{"text":"    return panic!(\"Something bad happened\")","highlight_start":5,"highlight_end":44}],"label":"unreachable expression","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\brand\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\std\\src\\panic.rs","byte_start":711,"byte_end":740,"line_start":22,"line_end":22,"column_start":9,"column_end":38,"is_primary":false,"text":[{"text":"        $crate::rt::begin_panic($msg)","highlight_start":9,"highlight_end":38}],"label":"any code following this expression is unreachable","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"testing.rs","byte_start":183,"byte_end":215,"line_start":6,"line_end":6,"column_start":12,"column_end":44,"is_primary":false,"text":[{"text":"    return panic!(\"Something bad happened\")","highlight_start":12,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"testing.rs","byte_start":183,"byte_end":215,"line_start":6,"line_end":6,"column_start":12,"column_end":44,"is_primary":false,"text":[{"text":"    return panic!(\"Something bad happened\")","highlight_start":12,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"panic!","def_site_span":{"file_name":"C:\\Users\\brand\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\std\\src\\macros.rs","byte_start":463,"byte_end":481,"line_start":13,"line_end":13,"column_start":1,"column_end":19,"is_primary":false,"text":[{"text":"macro_rules! panic {","highlight_start":1,"highlight_end":19}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},"macro_decl_name":"$crate::panic::panic_2015!","def_site_span":{"file_name":"C:\\Users\\brand\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc\\lib/rustlib/src/rust\\library\\std\\src\\panic.rs","byte_start":581,"byte_end":601,"line_start":17,"line_end":17,"column_start":1,"column_end":21,"is_primary":false,"text":[{"text":"pub macro panic_2015 {","highlight_start":1,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"`#[warn(unreachable_code)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;11mwarning\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: unreachable expression\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mtesting.rs:6:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m6\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    return panic!(\"Something bad happened\")\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m^^^^^^^\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--------------------------------\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11m|\u001b[0m\u001b[0m      \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14many code following this expression is unreachable\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;11munreachable expression\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: `#[warn(unreachable_code)]` on by default\u001b[0m\n\n"}
{"message":"return type cannot have an unboxed trait object","code":{"code":"E0746","explanation":"An unboxed trait object was used as a return value.\n\nErroneous code example:\n\n```compile_fail,E0746\ntrait T {\n    fn bar(&self);\n}\nstruct S(usize);\nimpl T for S {\n    fn bar(&self) {}\n}\n\n// Having the trait `T` as return type is invalid because\n// unboxed trait objects do not have a statically known size:\nfn foo() -> dyn T { // error!\n    S(42)\n}\n```\n\nReturn types cannot be `dyn Trait`s as they must be `Sized`.\n\nTo avoid the error there are a couple of options.\n\nIf there is a single type involved, you can use [`impl Trait`]:\n\n```\n# trait T {\n#     fn bar(&self);\n# }\n# struct S(usize);\n# impl T for S {\n#     fn bar(&self) {}\n# }\n// The compiler will select `S(usize)` as the materialized return type of this\n// function, but callers will only know that the return type implements `T`.\nfn foo() -> impl T { // ok!\n    S(42)\n}\n```\n\nIf there are multiple types involved, the only way you care to interact with\nthem is through the trait's interface, and having to rely on dynamic dispatch\nis acceptable, then you can use [trait objects] with `Box`, or other container\ntypes like `Rc` or `Arc`:\n\n```\n# trait T {\n#     fn bar(&self);\n# }\n# struct S(usize);\n# impl T for S {\n#     fn bar(&self) {}\n# }\nstruct O(&'static str);\nimpl T for O {\n    fn bar(&self) {}\n}\n\n// This now returns a \"trait object\" and callers are only be able to access\n// associated items from `T`.\nfn foo(x: bool) -> Box<dyn T> { // ok!\n    if x {\n        Box::new(S(42))\n    } else {\n        Box::new(O(\"val\"))\n    }\n}\n```\n\nFinally, if you wish to still be able to access the original type, you can\ncreate a new `enum` with a variant for each type:\n\n```\n# trait T {\n#     fn bar(&self);\n# }\n# struct S(usize);\n# impl T for S {\n#     fn bar(&self) {}\n# }\n# struct O(&'static str);\n# impl T for O {\n#     fn bar(&self) {}\n# }\nenum E {\n    S(S),\n    O(O),\n}\n\n// The caller can access the original types directly, but it needs to match on\n// the returned `enum E`.\nfn foo(x: bool) -> E {\n    if x {\n        E::S(S(42))\n    } else {\n        E::O(O(\"val\"))\n    }\n}\n```\n\nYou can even implement the `trait` on the returned `enum` so the callers\n*don't* have to match on the returned value to invoke the associated items:\n\n```\n# trait T {\n#     fn bar(&self);\n# }\n# struct S(usize);\n# impl T for S {\n#     fn bar(&self) {}\n# }\n# struct O(&'static str);\n# impl T for O {\n#     fn bar(&self) {}\n# }\n# enum E {\n#     S(S),\n#     O(O),\n# }\nimpl T for E {\n    fn bar(&self) {\n        match self {\n            E::S(s) => s.bar(),\n            E::O(o) => o.bar(),\n        }\n    }\n}\n```\n\nIf you decide to use trait objects, be aware that these rely on\n[dynamic dispatch], which has performance implications, as the compiler needs\nto emit code that will figure out which method to call *at runtime* instead of\nduring compilation. Using trait objects we are trading flexibility for\nperformance.\n\n[`impl Trait`]: https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits\n[trait objects]: https://doc.rust-lang.org/book/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types\n[dynamic dispatch]: https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch\n"},"level":"error","spans":[{"file_name":"testing.rs","byte_start":152,"byte_end":169,"line_start":5,"line_end":5,"column_start":36,"column_end":53,"is_primary":true,"text":[{"text":"pub extern \"C\" fn test_errors() -> std::error::Error{","highlight_start":36,"highlight_end":53}],"label":"doesn't have a size known at compile-time","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"use `impl std::error::Error` as the return type, as all return paths are of type `(dyn std::error::Error + 'static)`, which implements `std::error::Error`","code":null,"level":"help","spans":[{"file_name":"testing.rs","byte_start":152,"byte_end":169,"line_start":5,"line_end":5,"column_start":36,"column_end":53,"is_primary":true,"text":[{"text":"pub extern \"C\" fn test_errors() -> std::error::Error{","highlight_start":36,"highlight_end":53}],"label":null,"suggested_replacement":"impl std::error::Error","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0746]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: return type cannot have an unboxed trait object\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mtesting.rs:5:36\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m5\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub extern \"C\" fn test_errors() -> std::error::Error{\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mdoesn't have a size known at compile-time\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mnote\u001b[0m\u001b[0m: for information on `impl Trait`, see <https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits>\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14mhelp\u001b[0m\u001b[0m: use `impl std::error::Error` as the return type, as all return paths are of type `(dyn std::error::Error + 'static)`, which implements `std::error::Error`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m5\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0mpub extern \"C\" fn test_errors() -> \u001b[0m\u001b[0m\u001b[38;5;10mimpl std::error::Error\u001b[0m\u001b[0m{\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m                                    \u001b[0m\u001b[0m\u001b[38;5;10m~~~~~~~~~~~~~~~~~~~~~~\u001b[0m\n\n"}
{"message":"the trait bound `dyn std::error::Error: CTypeInfo` is not satisfied","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"testing.rs","byte_start":149,"byte_end":151,"line_start":5,"line_end":5,"column_start":33,"column_end":35,"is_primary":true,"text":[{"text":"pub extern \"C\" fn test_errors() -> std::error::Error{","highlight_start":33,"highlight_end":35}],"label":"the trait `CTypeInfo` is not implemented for `dyn std::error::Error`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the following other types implement trait `CTypeInfo`:\n  &'a T\n  &'a mut T\n  ()\n  *const T\n  *mut T\n  FFIBool\n  FFICChar\n  FFIOption<T>\nand 48 others","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0277]\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: the trait bound `dyn std::error::Error: CTypeInfo` is not satisfied\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m--> \u001b[0m\u001b[0mtesting.rs:5:33\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;14m5\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub extern \"C\" fn test_errors() -> std::error::Error{\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m| \u001b[0m\u001b[0m                                \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mthe trait `CTypeInfo` is not implemented for `dyn std::error::Error`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;14m= \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15mhelp\u001b[0m\u001b[0m: the following other types implement trait `CTypeInfo`:\u001b[0m\n\u001b[0m            &'a T\u001b[0m\n\u001b[0m            &'a mut T\u001b[0m\n\u001b[0m            ()\u001b[0m\n\u001b[0m            *const T\u001b[0m\n\u001b[0m            *mut T\u001b[0m\n\u001b[0m            FFIBool\u001b[0m\n\u001b[0m            FFICChar\u001b[0m\n\u001b[0m            FFIOption<T>\u001b[0m\n\u001b[0m          and 48 others\u001b[0m\n\n"}
{"message":"aborting due to 2 previous errors; 3 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m\u001b[38;5;15m: aborting due to 2 previous errors; 3 warnings emitted\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0277, E0746.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mSome errors have detailed explanations: E0277, E0746.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0277`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;15mFor more information about an error, try `rustc --explain E0277`.\u001b[0m\n"}
