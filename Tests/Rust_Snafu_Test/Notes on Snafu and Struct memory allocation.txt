Notes on Snafu:

Despite efforts to convert into a format that would work on the C layer, ffi does not like implicetly defined
structures that are found in the snafu formatted error enums and does not like snafu enums inside of functions.
It's then logical to conclude that errors cannot be done using snafu for this ffi, though the Rust "panic!" was
observed to be working.

Notes on dll calling while testing Snafu and error propogating:

Snafu appears to be tricky to get to propogate through Rust to C#, so the more generic panic! was used for
testing. While testing, a return message showed that C# treats dll calls as an unknown thread and the error
message did indeed come back from Rust to C#. The more interesting part is that dll calls are treated as 
threads from an unknown source. 

Passing Structs
https://learn.microsoft.com/en-us/dotnet/framework/interop/passing-structures

It appears from here that structs passed back are of an unmanaged signature, but can be used the same. Structs
are value types in C# so without indirection used with them, values passed back from a dll are treated as 
value types.


Callback functions
https://learn.microsoft.com/en-us/dotnet/framework/interop/callback-functions

Functions are considered unmanaged in C# which also means memory allocated and memory used in dll functions is
also unmanaged. I think this is likely because C# does not know the language the function this is coming from
nor how that function handles memory. What this does mean is that memory management for Rust functions is quite
tricky as ideally, this is handled on the C# side, but certain functions need to allocate memory on the Rust side.
For programming, this means more manual implementation of Rust functions that allocate memory or possibly 
splitting execution among two functions, a main function and a helper function while allocating memory on
C# inbetween.